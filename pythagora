#!/usr/bin/python -OO
# -*- coding: utf-8 -*
#-------------------------------------------------------------------------------
# Copyright 2009 E. A. Graham Jr. <txcrackers@gmail.com>.
# Copyright 2010 B. Kroon <bart@tarmack.eu>.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#-------------------------------------------------------------------------------
from PyQt4.QtCore import QTimer, SIGNAL, Qt
from PyQt4.QtGui import QApplication, QWidget, QSystemTrayIcon

import sys
import socket
import signal

import mpdextended as mpd
import playControls
import configuration
from MainWindow import View
import auxilia

#============== Long term TODO's ==============================================
# TODO: notification on song change (http://mpd.wikia.com/wiki/Mpd_osd.py_(using_dbus)
# TODO: Support default media buttons, probably with mod key. (halfway)
# TODO: build the actual Shoutcast support.
# TODO: Make us resistant against connection flicker.
# TODO: Use dbus to gain a new style KDE system tray icon.

# TODO: Refactor stuff:
#       * Method out stuff from __init_() in allot of classes.
#       * Class out and maybe thread mpd communication.

#==============================================================================

def main():
    app = QApplication(sys.argv)
    print 'debug:', sys.argv
    app.setOrganizationName("Tarmack SW")
    #app.setOrganizationName("HardSoft")
    app.setApplicationName("Pythagora")
    app.setKeyboardInputInterval(1600)
    view = Manager(app)
    signal.signal(signal.SIGINT, view.keyboardInterrupt)
    exit = app.exec_()
    sys.exit(exit)

#===============================================================================
# Creates and links up the management display items.
#===============================================================================
class Manager(View):
    '''Creates and links up the management display items.'''
    oldVolume = 0
    misses = 0
    def __init__(self, app):
        self.app = app
        self.mpdclient = mpd.MPDClient()
        self.timer = QTimer()
        self.idleTimer = QTimer()
        self.idleTimer.setSingleShot(True)
        self.config = configuration.Configuration()
        View.__init__(self, self.config, self.mpdclient, app)
        self.playControls = playControls.PlayControls(self.mpdclient)
        self.update = Update(self.view, self.mpdclient, self.config, self.playControls)
        if not self.__connectMPD():
            self.config.showConfiguration(self.view, True)
        self.__connectSignals()
        # Overload some methods.
        self.view.keyPressEvent = self.KeyPressEvent
        self.view.progress.mouseReleaseEvent = self.songSeek
        self.view.trayIcon.event = self.trayEvent

        self.timer.start(1000)

        self.view.progress.dragEnterEvent = self.__topEnter
        self.view.songLabel.dragEnterEvent = self.__topEnter
        self.view.progress.dropEvent = self.__topDrop
        self.view.songLabel.dropEvent = self.__topDrop


    def connectTo(self, action):
        name = unicode(action.text())
        if self.config.server and name == self.config.server[0] and self.mpdclient.connected():
            return
        if name == 'None (disconnect)':
            self.config.server = None
        else:
            self.config.server = [name]+self.config.knownHosts[name]
        self.__connectMPD()
        self.config.save()

    def callback(self, changes):
        '''Remember, this is executed from another thread.'''
        print 'debug: called back with "%s"' % changes
        if self.shuttingDown:
            print 'debug: callback aborted, application is closing down.'
            return
        if 'ConnectionError' in changes:
            self.view.emit(SIGNAL('ConnectionError'))
        else:
            self.view.emit(SIGNAL('update'), changes)
        # The slots will be executed asynchronously so we use a timer to
        # schedule the next idle call after all events have been processed.
        if self.idleTimer.timerId() < 0:
            self.idleTimer.start()

    def KeyPressEvent(self, event):
        if event.modifiers() == Qt.ControlModifier:
            if event.key() == Qt.Key_MediaPlay:
                self.playControls.playPause()
            elif event.key() == Qt.Key_MediaStop:
                self.playControls.stop()
            elif event.key() == Qt.Key_MediaPrevious:
                self.playControls.back()
            elif event.key() == Qt.Key_MediaNext:
                self.playControls.forward()
            elif event.key() == Qt.Key_VolumeUp:
                self.playControls.volumeUp()
            elif event.key() == Qt.Key_VolumeDown:
                self.playControls.volumeDown()
            elif event.key() == Qt.Key_VolumeMute:
                self.playControls.toggleMute()
        else: QWidget.keyPressEvent(self.view, event)

    def __update(self):
        if self.mpdclient._idle:
            self.update.progress()
        elif not self.app.closingDown():
            if not self.mpdclient._sock:
                self.__connectMPD()
        self.currentList.loadIcons()

    def __connectMPD(self):
        if self.shuttingDown:
            return True
        self.update.setProgress(0, 0)
        self.update.lastSongId = None
        if self.mpdclient.connected():
            self.mpdclient.close()
            self.mpdclient.disconnect()
        socket.setdefaulttimeout(1)
        server = self.config.server
        try:
            if not server:
                self.update.setSongLabel('Not connected')
                self.view.serverLabel.setText('Not connected')
                self.update.clearForms()
                self.update.currentsong = {}
                self.idleTimer.setInterval(10000)
                return None
            else:
                self.view.setCursor(Qt.WaitCursor)
                self.view.serverLabel.setText('Connecting to %s' % server[0])
                self.mpdclient.connect(server[1], int(server[2]))
                if len(server) > 3 and server[3] != '':
                    self.mpdclient.password(server[3])
                self.update.currentsong = self.mpdclient.currentsong()
                self.view.serverLabel.setText('Connected to %s' % server[0])
                self.idleTimer.setInterval(0)
                self.update.update(['player', 'mixer', 'options'])
                self.misses = 0
                self.errorCount = 0
                return True
        except Exception, e:
            self.update.setSongLabel('Could not connect to %s at %s (%s).' % (server[0], server[1], e))
            self.view.serverLabel.setText('Not connected')
            self.update.clearForms()
            self.update.currentsong = {}
            self.misses += 1
            return False
        finally:
            print 'debug: tried to connect again :$'
            self.view.emit(SIGNAL('resetCurrentList()'))
            self.view.emit(SIGNAL('reloadLibrary()'))
            self.view.setCursor(Qt.ArrowCursor)
            if self.idleTimer.timerId() < 0:
                self.idleTimer.start()

    def _error(self):
        if self.config.server:
            if self.errorCount > 0:
                print 'error: Lost connection to mpd server.'
                if not self.misses or (self.errorCount / self.misses) % 10 == 0:
                    if self.__connectMPD():
                        return
                    else:
                        # Let the user know we went wrong somewhere.
                        self.setProgress(0, 0)
                        self.lastSongId = None
                        self.view.play.setIcon(self.startIcon)
            self.errorCount += 1

    def songSeek(self, event):
        if event.button() == Qt.LeftButton:
            status = self.mpdclient.currentsong()
            time = status.get('time', None)
            if time is not None:
                value = float(event.x()) / int(self.view.progress.geometry().width())
                self.mpdclient.seekid(status['id'], int(int(time) * value))

    def trayEvent(self, event):
        if event.type() == 31: # enum: QEvent.wheel
            event.accept()
            self.playControls.volumeUp(int(event.delta())/(8*15))
            return True
        else:
            QSystemTrayIcon.event(self.view.trayIcon, event)
            return False

    def __runIdle(self):
        if not self.shuttingDown and self.mpdclient.connected():
            self.mpdclient.idleThread(self.callback, timeout=10)

    def __topEnter(self, event):
        if event.source() != self.view.currentList:
            event.accept()

    def __topDrop(self, event):
        event.accept()
        self.mpdclient.clear()
        self.currentList.dropEvent(event, append=True)
        self.mpdclient.play()

    def __connectSignals(self):
        self.playControls.connectSignals(self.view)
        self.view.connect(self.view.menuConnect, SIGNAL('triggered(QAction *)'), self.connectTo)

        self.view.connect(self.timer, SIGNAL("timeout()"), self.__update)
        self.view.connect(self.idleTimer, SIGNAL("timeout()"), self.__runIdle)
        self.view.connect(self.view, SIGNAL('reconnect()'), self.__connectMPD)
        self.view.connect(self.view, SIGNAL('ConnectionError()'), self._error)

    def keyboardInterrupt(self, signum, frame):
        print 'debug: KeyboardInterrupt'
        try:
            self.app.quit()
        except:
            sys.exit(1)


class Update:
    lastSongId = None
    state = None
    misses = 0
    errorCount = 0
    time = 0
    def __init__(self, view, mpdclient, config, playControls):
        self.pauseIcon = auxilia.PIcon("media-playback-pause")
        self.startIcon = auxilia.PIcon("media-playback-start")
        self.view = view
        self.mpdclient = mpdclient
        self.config = config
        self.playControls = playControls
        self.view.connect(self.view, SIGNAL('update'), self.update)

    def update(self, changes):
        try:
            status = self.mpdclient.status()
            self.errorCount = 0
        except Exception, e:
            print 'error: update error', e
            self.view.emit(SIGNAL('ConnectionError()'))
            return
        if changes:
            for change in changes:
                getattr(self, change)(status)
        else:
            self.player(status)

    def progress(self):
            try:
                if self.state == 'play':
                    if 'time' in self.currentsong:
                        self.setProgress(self.time + 1)
                    else:
                        self.setProgress(self.time, 0)
            except Exception, e:
                print 'error: updateProgress error', e

    def playlist(self, status):
        self.view.emit(SIGNAL('playlistChanged()'))

    def player(self, status):
        #try:
        if self.state != status['state']:
            self.__setPlayPauseState(status['state'])
        # if we're stopped, just call it quits
        if status['state'] == 'stop':
            self.setProgress(0, 0)
            self.view.emit(SIGNAL('currentSong'), None)
            self.setSongLabel('Connected to %s.' % self.config.server[0])
            return
        cs, ss = status['time'].split(':')
        self.setProgress(cs, ss)
        currentSong = int(status.get('song', None))
        if status['songid'] != self.lastSongId:
            self.view.emit(SIGNAL('currentSong'), currentSong)
            self.currentsong = self.mpdclient.currentsong()
            album = self.currentsong.get('album', 'Unknown')
            self.shoutcastCount = 0
            self.setSongLabel(auxilia.songTitle(self.currentsong), auxilia.songArtist(self.currentsong), album)
            # format times
            self.lastSongId = status['songid']

        # Check if volume chaged behind our back.
        self.mixer(status)

    def mixer(self, status):
        volumeStatus = int(status['volume'])
        self.playControls.currentVolume = volumeStatus
        self.view.volume.setValue(volumeStatus)

    def options(self, status):
        self.view.repeatButton.setChecked(bool(int(status['repeat'])))
        self.view.randomButton.setChecked(bool(int(status['random'])))
        self.view.crossFade.setValue(int(status['xfade']))

    def stored_playlist(self, status):
        self.view.emit(SIGNAL('reloadPlaylists()'))

    def database(self, status):
        self.view.emit(SIGNAL('reloadLibrary()'))

    def setSongLabel(self, title='', artist='', album=''):
        self.view.trayIcon.setToolTip('<b><big>%s</big></b>\r\nby <big>%s</big>\r\nfrom <i>%s</i>' % (title, artist, album))
        self.view.songLabel.setText(title, artist, album)

    def setProgress(self, cs, ss=None):
        ''' Moves the progress indicator to the correct position,
            calculate the timestamps and puts them in place.
        '''
        if ss is None:
            ss = self.view.progress.maximum()
        curTime = int(cs)
        songTime = int(ss)
        if songTime <= 0:
            self.view.progress.setValue(0)
            self.view.progress.setFormat(formatTime(curTime))
        else:
            self.view.progress.setMaximum(songTime)
            self.view.progress.setValue(curTime)
            self.view.progress.setFormat('/'.join((formatTime(curTime), formatTime(songTime))))
        self.time = curTime

    def clearForms(self):
        self.view.artistView.clear()
        self.view.albumView.clear()
        self.view.trackView.clear()
        self.view.filesystemTree.clear()
        self.view.playlistList.clear()
        self.view.songList.clear()

    def __setPlayPauseState(self,state):
        if state == 'play':
            self.view.play.setIcon(self.pauseIcon)
            self.view.trayIcon.setIcon(self.pauseIcon)
            self.state = 'play'
        else:
            self.view.play.setIcon(self.startIcon)
            self.view.trayIcon.setIcon(self.startIcon)
            self.state = 'stop'

def formatTime(seconds):
    seconds = int(seconds)
    form = '%i'
    result = []
    units = (60*60*24, 60*60, 60)
    for size in units:
        if seconds > size-1 or form == '%02i':
            count = seconds / size
            seconds -= (count * size)
            result.append(form % count)
            form = '%02i'
    result.append('%02i' % seconds)
    if len(result) < 2:
        result.insert(0, '0')
    return ':'.join(result)


if __name__ == "__main__":
    for opt in sys.argv:
        if opt == "-h" or opt.startswith("--help"):
            import usage
            print usage.usage
            if opt == "--help-qt":
                print usage.qtOptions
            sys.exit(0)
    import WriteOut
    # silence pyflakes.
    WriteOut.Quiet()

    main()
#    import cProfile
#    cProfile.run('main()')

